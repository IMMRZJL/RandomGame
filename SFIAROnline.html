<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>技能五子棋 · 联机房间</title>
<style>
  :root{
    --bg:#0f172a; --panel:#111827; --text:#e5e7eb; --muted:#94a3b8;
    --freeze:rgba(56,189,248,.20); --ruin:rgba(239,68,68,.18);
    --void:rgba(99,102,241,.22);
    --btn:#1f2937; --btn-hover:#374151; --ok:#22c55e; --bad:#ef4444;
  }
  *{box-sizing:border-box}
  body{margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,"PingFang SC","Microsoft YaHei",Arial,"Noto Sans",sans-serif;
       background:linear-gradient(135deg,#0b1020,#0f172a 60%,#101827); color:var(--text); min-height:100vh}
  .wrap{max-width:1200px; margin:0 auto; padding:16px; display:grid; gap:16px; grid-template-columns:1fr 380px}
  .panel{background:var(--panel); border-radius:16px; padding:14px; box-shadow:0 6px 24px rgba(0,0,0,.3)}
  .title{font-weight:800; margin:0 0 8px 0; display:flex; justify-content:space-between; align-items:center}
  canvas{display:block; background:#f7e9c5; border-radius:14px; box-shadow:inset 0 0 0 1px rgba(0,0,0,.08)}
  .row{display:flex; gap:8px; flex-wrap:wrap; align-items:center}
  .btn{background:var(--btn); color:var(--text); border:none; padding:10px 12px; border-radius:12px; cursor:pointer; transition:.15s}
  .btn:hover{background:var(--btn-hover)}
  .pill{font-size:.8rem; padding:4px 10px; border-radius:999px; background:#0b1220; color:#cbd5e1}
  .ok{background:rgba(34,197,94,.15); color:#a7f3d0}
  .cd{background:rgba(251,191,36,.15); color:#fde68a}
  .turn{font-weight:900; padding:6px 12px; border-radius:12px}
  .turn.black{background:rgba(0,0,0,.85); color:#fff}
  .turn.white{background:#fff; color:#111; box-shadow:0 0 0 2px rgba(0,0,0,.2) inset}
  input,select{background:#0b1220; border:1px solid rgba(255,255,255,.1); color:#e5e7eb; border-radius:10px; padding:8px 10px}

  .chat{background:#0b1220; border:1px solid rgba(255,255,255,.08); border-radius:12px; padding:10px; height:200px; overflow:auto; font-size:.92rem; line-height:1.35;}
  .chat .msg{margin:2px 0}
  .chat .me{color:#a7f3d0}
  .chat .sys{color:#fde68a}

  .players{display:grid; grid-template-columns:repeat(2,minmax(0,1fr)); gap:6px}
  .player{display:flex; align-items:center; gap:8px; background:#0b1220; border:1px solid rgba(255,255,255,.08); border-radius:10px; padding:6px 8px}
  .dot{width:10px;height:10px;border-radius:50%}
  .dot.black{background:#111}
  .dot.white{background:#fff; box-shadow:0 0 0 1px rgba(0,0,0,.2) inset}
  .dot.spec{background:#64748b}

  @media(max-width:1024px){ .wrap{grid-template-columns:1fr} }

  /* Win modal */
  .win{position:fixed; inset:0; display:none; place-items:center; backdrop-filter:blur(6px); background:rgba(0,0,0,.25); z-index:50}
  .win .box{background:#0e1628; border:1px solid rgba(255,255,255,.08); padding:22px; border-radius:16px; width:min(92vw,420px)}
  .win .box h3{margin:0 0 8px 0}
</style>
</head>
<body>
<div class="wrap">
  <div class="panel">
    <h2 class="title">
      技能五子棋 · 联机
      <span id="roomInfo" class="pill">未入房</span>
    </h2>
    <canvas id="board" width="640" height="640" aria-label="Gomoku board"></canvas>
  </div>

  <div class="panel">
    <h3 class="title">大厅与状态 <span id="conn" class="pill">离线</span></h3>
    <div class="row" style="margin:6px 0 8px">
      <input id="roomId" placeholder="房间号，如 12345" style="flex:1 1 140px" />
      <input id="nickname" placeholder="昵称" style="flex:1 1 120px" />
      <select id="seat">
        <option value="1">黑方</option>
        <option value="2">白方</option>
        <option value="0">旁观</option>
      </select>
      <button id="joinBtn" class="btn">进入房间</button>
    </div>

    <div class="row" style="margin:6px 0">
      <span id="turnTag" class="turn black">黑方回合</span>
    </div>

    <div class="row" style="margin:10px 0 8px">
      <button id="placeMode" class="btn">落子模式</button>
      <button id="resetBtn" class="btn">新局</button>
    </div>

    <h4 style="margin:10px 0 6px">技能</h4>
    <div class="row">
      <button id="skillSand" class="btn">飞沙走石 <span id="cdSand" class="pill cd">CD 0</span></button>
      <button id="skillFreeze" class="btn">静如止水 <span id="cdFreeze" class="pill cd">CD 0</span></button>
      <button id="skillHurl" class="btn">力拔山兮 <span id="cdHurl" class="pill cd">CD 0</span></button>
      <button id="skillRewind" class="btn">回溯时光 <span id="cdRewind" class="pill cd">CD 0</span></button>
      <!-- 新增两个技能按钮 -->
      <button id="skillSimo" class="btn">四面楚歌 <span id="cdSimo" class="pill cd">CD 0</span></button>
      <button id="skillGenius" class="btn">神来一笔 <span id="cdGenius" class="pill cd">CD 0</span></button>
    </div>

    <p id="hint" style="color:#94a3b8; margin-top:8px">提示会显示在这里</p>

    <h4 style="margin:12px 0 6px">当前玩家</h4>
    <div id="players" class="players"></div>

    <h4 style="margin:12px 0 6px">聊天室</h4>
    <div id="chatList" class="chat"></div>
    <div class="chatInput">
      <input id="chatInput" placeholder="说点什么…" style="flex:1 1 auto" />
      <button id="chatSend" class="btn">发送</button>
    </div>
  </div>
</div>

<div id="winModal" class="win">
  <div class="box">
    <h3 id="winText">黑方胜利</h3>
    <p id="winMsg" style="color:#cbd5e1">恭喜获胜。</p>
    <div class="row" style="margin-top:10px">
      <button class="btn" onclick="document.getElementById('winModal').style.display='none'">继续对局</button>
      <button class="btn" id="winReset">新局</button>
    </div>
  </div>
</div>

<div class="panel" style="max-width:1200px; margin:0 auto 24px; grid-column:1/-1">
  <h3 class="title" style="margin-bottom:8px">技能说明书</h3>
  <ol style="margin:6px 0 0 18px; color:#cbd5e1; line-height:1.55">
    <li><b>飞沙走石</b>：以你最近两手之一为中心 8 邻域内，选定一个 2×2 区域，清除区域内对方棋子，并生成“废墟”阻挡 2 回合。冷却 5 回合。</li>
    <li><b>静如止水</b>：以点击格为中心的 3×3 区域冻结 3 回合，仅一方可同时维持冻结。冷却 5 回合。</li>
    <li><b>力拔山兮</b>（改版）：先选自己一子，再选目标中心，把该己子与邻近随机一颗对方子，分别甩到目标 3×3 的两个随机空位。冷却 5 回合。</li>
    <li><b>回溯时光</b>：移除对手上一手，并在该格生成“时空黑洞”，3 回合内双方均不得在此落子。冷却 6 回合。</li>
    <li><b>四面楚歌</b>（新增）：若己方某子被 3×3 八邻全部为对方子所包围，点该子可随机移除其周围两颗对方子。冷却 5 回合。</li>
    <li><b>神来一笔</b>（新增）：点击后随机高亮一个空位，再次点击“神来一笔”确认在该处落子；也可点“落子模式”放弃。落子带一个简短的缩放动画。冷却 5 回合。</li>
    <li>预览：非己方回合或处于冷却时仍可点击技能进行<strong>效果预览</strong>，但无法实际释放。</li>
  </ol>
</div>

<script type="module">
/* ---------- Firebase ---------- */
import { initializeApp } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-app.js";
import {
  getDatabase, ref, onValue, set, runTransaction, onDisconnect,
  serverTimestamp, push, onChildAdded, query, limitToLast
} from "https://www.gstatic.com/firebasejs/12.3.0/firebase-database.js";
import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-auth.js";

/* Replace with your own config */
const firebaseConfig = {
  apiKey: "AIzaSyARTxHp8gi-UR9bY5IVSWxUPiSzCawzdsE",
  authDomain: "sfiar-606ea.firebaseapp.com",
  databaseURL: "https://sfiar-606ea-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId: "sfiar-606ea",
  storageBucket: "sfiar-606ea.appspot.com",
  messagingSenderId: "153196240063",
  appId: "1:153196240063:web:ae178909438892a5a1fa0a"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);
const auth = getAuth(app);
signInAnonymously(auth).catch(console.error);

/* ---------- Game constants ---------- */
const BOARD_SIZE = 15;
const CELL = 40;
const MARGIN = 20;
const FREEZE_TURNS = 3;
const RUIN_TURNS = 2;
const VOID_TURNS = 3;
// 扩展 CD，新增 simo、genius
const CD = { sand:5, freeze:5, hurl:5, rewind:6, simo:5, genius:5 };

/* ---------- Local state ---------- */
let room = null, uid = crypto.randomUUID();
let mySeat = 0; // 1 black, 2 white, 0 spectator
let nickname = "";
let state = null; // authoritative
// 扩展可用模式
let mode = 'place'; // place | sand | freeze | hurlSelect | hurlTarget | rewindPreview | simo | geniusPreview
let leapFrom = null; // for hurl
let hoverCell = null;
let prevWinner = 0;
let geniusPick = null; // 神来一笔预选空位

/* ---------- DOM ---------- */
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');
const roomInfo = document.getElementById('roomInfo');
const conn = document.getElementById('conn');
const hint = document.getElementById('hint');
const turnTag = document.getElementById('turnTag');
const inputRoom = document.getElementById('roomId');
const inputName = document.getElementById('nickname');
const seatSel = document.getElementById('seat');
const btnJoin = document.getElementById('joinBtn');
const btnPlace = document.getElementById('placeMode');
const btnReset = document.getElementById('resetBtn');
const btnSand = document.getElementById('skillSand');
const btnFreeze = document.getElementById('skillFreeze');
const btnHurl = document.getElementById('skillHurl');
const btnRewind = document.getElementById('skillRewind');
// 新增按钮与 CD 节点
const btnSimo = document.getElementById('skillSimo');
const btnGenius = document.getElementById('skillGenius');
const cdSand = document.getElementById('cdSand');
const cdFreeze = document.getElementById('cdFreeze');
const cdHurl = document.getElementById('cdHurl');
const cdRewind = document.getElementById('cdRewind');
const cdSimo = document.getElementById('cdSimo');
const cdGenius = document.getElementById('cdGenius');
const chatList = document.getElementById('chatList');
const chatInput = document.getElementById('chatInput');
const chatSend = document.getElementById('chatSend');
const playersBox = document.getElementById('players');
const winModal = document.getElementById('winModal');
const winText = document.getElementById('winText');
const winMsg  = document.getElementById('winMsg');
document.getElementById('winReset').onclick = ()=>resetRoom();

/* ---------- Helpers ---------- */
const clamp=(v,min,max)=>Math.min(max,Math.max(min,v));
function line(x1,y1,x2,y2){ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.stroke();}
function dot(x,y,r){ctx.beginPath();ctx.arc(x,y,r,0,Math.PI*2);ctx.fill();}
function stone(x,y,color){
  const r = CELL*0.42;
  const g = ctx.createRadialGradient(x-r*0.25,y-r*0.25,r*0.2,x,y,r);
  if(color==='#fff'){g.addColorStop(0,'#fff'); g.addColorStop(1,'#d1d5db');}
  else{g.addColorStop(0,'#222'); g.addColorStop(1,'#000');}
  ctx.fillStyle=g; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
}
function snow(x,y){
  const s=CELL*0.18;
  ctx.beginPath();
  ctx.moveTo(x-s,y);ctx.lineTo(x+s,y);
  ctx.moveTo(x,y-s);ctx.lineTo(x,y+s);
  ctx.moveTo(x-s*0.7,y-s*0.7);ctx.lineTo(x+s*0.7,y+s*0.7);
  ctx.moveTo(x+s*0.7,y-s*0.7);ctx.lineTo(x-s*0.7,y+s*0.7);
  ctx.strokeStyle='rgba(96,165,250,.8)'; ctx.lineWidth=1; ctx.stroke();
}
function cracks(x,y){
  const s=CELL*0.18;
  ctx.beginPath();
  ctx.moveTo(x-s,y);ctx.lineTo(x+s,y);
  ctx.moveTo(x-s*0.6,y);ctx.lineTo(x,y+s*0.6);
  ctx.moveTo(x,y-s*0.6);ctx.lineTo(x+s*0.6,y);
  ctx.strokeStyle='rgba(239,68,68,.8)'; ctx.lineWidth=1; ctx.stroke();
}
function vortex(x,y){
  const r=CELL*0.42;
  const grd=ctx.createRadialGradient(x,y,0,x,y,r);
  grd.addColorStop(0,'rgba(17,24,39,.95)');
  grd.addColorStop(1,'rgba(99,102,241,.35)');
  ctx.fillStyle=grd;
  ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
  ctx.strokeStyle='rgba(99,102,241,.9)'; ctx.lineWidth=2;
  ctx.beginPath(); ctx.arc(x,y,r*0.7,0,Math.PI*2); ctx.stroke();
}
function ring(x,y,color){
  ctx.strokeStyle=color; ctx.lineWidth=2;
  ctx.beginPath(); ctx.arc(x,y,CELL*0.48,0,Math.PI*2); ctx.stroke();
}
function rectStroke(x,y,w,h,style='rgba(234,179,8,.95)'){
  ctx.strokeStyle=style; ctx.lineWidth=2; ctx.strokeRect(x,y,w,h);
}
function setHint(t){ if(hint) hint.textContent = t; }
function sysMsg(t){
  const div=document.createElement('div'); div.className='msg sys'; div.textContent=t;
  chatList.appendChild(div); chatList.scrollTop=chatList.scrollHeight;
}
function screenToCell(ev){
  const rect=canvas.getBoundingClientRect();
  const cx = ev.clientX ?? ev.touches?.[0]?.clientX;
  const cy = ev.clientY ?? ev.touches?.[0]?.clientY;
  const x = ((cx-rect.left)-MARGIN)/CELL, y = ((cy-rect.top)-MARGIN)/CELL;
  return {x: clamp(Math.round(x),0,BOARD_SIZE-1), y: clamp(Math.round(y),0,BOARD_SIZE-1)};
}
// 新增 - 被包围判定与候选列表、随机空位
function isSurrounded(x,y,me){
  if(x===0||y===0||x===BOARD_SIZE-1||y===BOARD_SIZE-1) return false; // 边界不算
  const opp = 3-me;
  for(let dy=-1;dy<=1;dy++){
    for(let dx=-1;dx<=1;dx++){
      if(dx===0&&dy===0) continue;
      const nx=x+dx, ny=y+dy;
      if(nx<0||ny<0||nx>=BOARD_SIZE||ny>=BOARD_SIZE) return false;
      if(state.board[ny][nx]!==opp) return false;
    }
  }
  return true;
}
function listSimoCandidates(me){
  const arr=[];
  for(let y=1;y<BOARD_SIZE-1;y++){
    for(let x=1;x<BOARD_SIZE-1;x++){
      if(state.board[y][x]===me && isSurrounded(x,y,me)) arr.push({x,y});
    }
  }
  return arr;
}
function pickRandomEmpty(){
  const empty=[];
  for(let y=0;y<BOARD_SIZE;y++){
    for(let x=0;x<BOARD_SIZE;x++){
      if(state.board[y][x]===0 && !blocked(x,y)) empty.push({x,y});
    }
  }
  if(empty.length===0) return null;
  return empty[Math.floor(Math.random()*empty.length)];
}

/* ---------- Drawing ---------- */
function drawBoard(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = '#f7e9c5'; ctx.fillRect(0,0,canvas.width,canvas.height);

  // effects base layers
  if(state){
    for(let y=0;y<BOARD_SIZE;y++){
      for(let x=0;x<BOARD_SIZE;x++){
        if(state.ruin[y][x]>0){
          ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--ruin');
          ctx.fillRect(MARGIN+x*CELL - CELL/2 +1, MARGIN+y*CELL - CELL/2 +1, CELL-2, CELL-2);
          cracks(MARGIN+x*CELL, MARGIN+y*CELL);
        }
        if(state.freeze[y][x]>0){
          ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--freeze');
          ctx.fillRect(MARGIN+x*CELL - CELL/2 +1, MARGIN+y*CELL - CELL/2 +1, CELL-2, CELL-2);
          snow(MARGIN+x*CELL, MARGIN+y*CELL);
        }
        if(state.voids[y][x]>0){
          ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--void');
          ctx.fillRect(MARGIN+x*CELL - CELL/2 +1, MARGIN+y*CELL - CELL/2 +1, CELL-2, CELL-2);
          vortex(MARGIN+x*CELL, MARGIN+y*CELL);
        }
      }
    }
  }

  // grid
  ctx.strokeStyle='#bfa87a'; ctx.lineWidth=1;
  for(let i=0;i<BOARD_SIZE;i++){
    const p = MARGIN + i*CELL;
    ctx.beginPath(); ctx.moveTo(p, MARGIN); ctx.lineTo(p, MARGIN+(BOARD_SIZE-1)*CELL); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(MARGIN, p); ctx.lineTo(MARGIN+(BOARD_SIZE-1)*CELL, p); ctx.stroke();
  }

  // star points
  const stars=[3,7,11]; ctx.fillStyle='#8b6b34';
  stars.forEach(sx=>stars.forEach(sy=>{ ctx.beginPath(); ctx.arc(MARGIN+sx*CELL, MARGIN+sy*CELL, 3, 0, Math.PI*2); ctx.fill(); }));

  // stones
  if(state){
    for(let y=0;y<BOARD_SIZE;y++){
      for(let x=0;x<BOARD_SIZE;x++){
        const v = state.board[y][x]; if(!v) continue;
        const color = v===1? '#111' : '#fff';
        const cx=MARGIN+x*CELL, cy=MARGIN+y*CELL;
        const r = CELL*0.42;
        const g = ctx.createRadialGradient(cx-r*0.25,cy-r*0.25,r*0.2,cx,cy,r);
        if(color==='#fff'){g.addColorStop(0,'#fff'); g.addColorStop(1,'#d1d5db');}
        else{g.addColorStop(0,'#222'); g.addColorStop(1,'#000');}
        ctx.fillStyle=g; ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill();
      }
    }
    if(state.lastMove){
      ctx.strokeStyle = '#22c55e'; ctx.lineWidth=2;
      ctx.strokeRect(MARGIN+state.lastMove.x*CELL - CELL/2 +3, MARGIN+state.lastMove.y*CELL - CELL/2 +3, CELL-6, CELL-6);
    }
  }

  // hover previews and skill anchors
  if(hoverCell && state){
    const {x,y} = hoverCell;
    if(mode==='freeze'){
      rectStroke(MARGIN+(x-1)*CELL - CELL/2 +2, MARGIN+(y-1)*CELL - CELL/2 +2, CELL*3-4, CELL*3-4,'rgba(96,165,250,.9)');
    }
    if(mode==='sand'){
      // highlight 2x2 placement and show my last two anchors
      const tlx = clamp(x,0,BOARD_SIZE-2), tly = clamp(y,0,BOARD_SIZE-2);
      rectStroke(MARGIN+tlx*CELL - CELL/2 +2, MARGIN+tly*CELL - CELL/2 +2, CELL*2-4, CELL*2-4,'rgba(239,68,68,.9)');
      const anchors = state.recent2?.[mySeat] || [];
      anchors.forEach(a=> ring(MARGIN+a.x*CELL, MARGIN+a.y*CELL, 'rgba(239,68,68,.95)'));
    }
    if(mode==='hurlTarget'){
      rectStroke(MARGIN+(x-1)*CELL - CELL/2 +2, MARGIN+(y-1)*CELL - CELL/2 +2, CELL*3-4, CELL*3-4,'rgba(234,179,8,.95)');
    }
  }
  if(mode==='rewindPreview' && state){
    const lm = state.lastMoveByPlayer?.[3-mySeat];
    if(lm){
      ring(MARGIN+lm.x*CELL, MARGIN+lm.y*CELL, 'rgba(99,102,241,.95)');
      vortex(MARGIN+lm.x*CELL, MARGIN+lm.y*CELL);
    }
  }
  // 新增：simo 候选高亮与 genius 预览高亮
  if(mode==='simo' && state){
    const cands = listSimoCandidates(state.turn);
    cands.forEach(({x,y})=> ring(MARGIN+x*CELL, MARGIN+y*CELL, 'rgba(234,179,8,.95)'));
  }
  if(mode==='geniusPreview' && geniusPick){
    ring(MARGIN+geniusPick.x*CELL, MARGIN+geniusPick.y*CELL, 'rgba(16,185,129,.95)');
  }
}

/* ---------- Base state ---------- */
function emptyState(){
  return {
    board: Array.from({length:BOARD_SIZE},()=>Array(BOARD_SIZE).fill(0)),
    freeze: Array.from({length:BOARD_SIZE},()=>Array(BOARD_SIZE).fill(0)),
    ruin:   Array.from({length:BOARD_SIZE},()=>Array(BOARD_SIZE).fill(0)),
    voids:  Array.from({length:BOARD_SIZE},()=>Array(BOARD_SIZE).fill(0)),
    turn: 1,
    // 扩展 cooldowns
    cooldowns: {1:{sand:0,freeze:0,hurl:0,rewind:0,simo:0,genius:0}, 2:{sand:0,freeze:0,hurl:0,rewind:0,simo:0,genius:0}},
    lastMove: null,
    lastMoveByPlayer: {1:null,2:null},
    recent2: {1:[],2:[]},
    freezeOwner: 0,
    winner: 0
  };
}

/* ---------- Join room and presence ---------- */
async function joinRoom(){
  const rid = inputRoom.value.trim(); const name = inputName.value.trim() || '玩家';
  const seat = Number(seatSel.value);
  if(!rid){ alert('请输入房间号'); return; }
  room = rid; nickname = name; mySeat = seat;

  const playersRef = ref(db, `rooms/${room}/players/${uid}`);
  await set(playersRef, { name:nickname, seat:mySeat, ts: serverTimestamp() });
  onDisconnect(playersRef).remove();

  roomInfo.textContent = `房间 ${room}（你是${seat===1?'黑':seat===2?'白':'旁观'}）`;
  conn.textContent = '在线'; conn.className='pill ok';
  setHint('已进入房间。选择落子或技能。');

  // create state if not exists
  await runTransaction(ref(db, `rooms/${room}/state`), s => s ? s : emptyState());

  // players list
  onValue(ref(db, `rooms/${room}/players`), snap=>{
    const val = snap.val()||{};
    const items = Object.values(val).map(p=>{
      const dot = p.seat===1 ? '<span class="dot black"></span>' : p.seat===2 ? '<span class="dot white"></span>' : '<span class="dot spec"></span>';
      const seat = p.seat===1?'黑':p.seat===2?'白':'旁观';
      return `<div class="player">${dot}<span>${p.name || '玩家'}</span><span class="pill" style="margin-left:auto">${seat}</span></div>`;
    });
    playersBox.innerHTML = items.join('') || '<div style="color:#94a3b8">暂无玩家</div>';
  });

  // listen state
  onValue(ref(db, `rooms/${room}/state`), snap=>{
    const val = snap.val(); if(!val) return;
    state = val;
    updateUI();
    drawBoard();
    if(state.winner && state.winner!==prevWinner){
      prevWinner = state.winner;
      winText.textContent = (state.winner===1?'黑方':'白方') + '胜利';
      // winner / loser specific message
      if(mySeat===state.winner) winMsg.textContent = '恭喜获胜';
      else if(mySeat===0) winMsg.textContent = '本局已分出胜负';
      else winMsg.textContent = '再接再厉';
      winModal.style.display='grid';
    }
  });

  // chat
  const cRef = ref(db, `rooms/${room}/chat`);
  onChildAdded(query(cRef, limitToLast(100)), s=>{
    const m = s.val();
    const who = m.uid===uid ? 'me' : 'other';
    const seatLabel = m.seat===1?'⚫':'⚪';
    const div = document.createElement('div');
    div.className = 'msg ' + (who==='me'?'me':'');
    div.textContent = `${seatLabel} ${m.name}: ${m.text}`;
    chatList.appendChild(div);
    chatList.scrollTop = chatList.scrollHeight;
  });
}
btnJoin.onclick = joinRoom;

/* ---------- UI ---------- */
function updateUI(){
  if(!state){
    [btnSand, btnFreeze, btnHurl, btnRewind, btnSimo, btnGenius].forEach(b=>b.disabled=true);
    return;
  }
  const whoText = state.turn===1?'黑方':'白方';
  turnTag.textContent = `${whoText}回合`;
  turnTag.className = 'turn ' + (state.turn===1?'black':'white');

  const show = (el, v)=>{ el.textContent = v <= 0 ? '就绪' : `CD ${v}`; el.className = v <= 0 ? 'pill ok' : 'pill cd'; };
  const myBucket = (mySeat===1||mySeat===2) ? state.cooldowns?.[mySeat] : null;
  show(cdSand,   myBucket?.sand   ?? 99);
  show(cdFreeze, myBucket?.freeze ?? 99);
  show(cdHurl,   myBucket?.hurl   ?? 99);
  show(cdRewind, myBucket?.rewind ?? 99);
  show(cdSimo,   myBucket?.simo   ?? 99);
  show(cdGenius, myBucket?.genius ?? 99);

  // 不再禁用技能按钮，允许预览
  [btnSand, btnFreeze, btnHurl, btnRewind, btnSimo, btnGenius].forEach(b=>b.disabled=false);

  setHint(`你是${mySeat===1?'黑':mySeat===2?'白':'旁观'}。每回合只能落子或释放一个技能。`);
}

/* ---------- Rule helpers ---------- */
function cellFrozen(x,y){ return state.freeze[y][x]>0; }
function cellRuined(x,y){ return state.ruin[y][x]>0; }
function cellVoid(x,y){ return state.voids?.[y]?.[x]>0; }
function blocked(x,y){ return cellFrozen(x,y) || cellRuined(x,y) || cellVoid(x,y); }

function checkWin(board,x,y,color){
  const dirs = [[1,0],[0,1],[1,1],[1,-1]];
  for(const [dx,dy] of dirs){
    let c=1; c+=count(board,x,y,dx,dy,color); c+=count(board,x,y,-dx,-dy,color);
    if(c>=5) return true;
  }
  return false;
}
function count(board,x,y,dx,dy,color){
  let k=0,nx=x+dx,ny=y+dy;
  while(nx>=0&&ny>=0&&nx<BOARD_SIZE&&ny<BOARD_SIZE&&board[ny][nx]===color){k++; nx+=dx; ny+=dy;}
  return k;
}

/* ---------- Turn helpers ---------- */
function decEffects(s){
  for(let y=0;y<BOARD_SIZE;y++){
    for(let x=0;x<BOARD_SIZE;x++){
      if(s.freeze[y][x]>0) s.freeze[y][x]--;
      if(s.ruin[y][x]>0) s.ruin[y][x]--;
      if(s.voids?.[y]?.[x]>0) s.voids[y][x]--;
    }
  }
  if(!s.freeze.flat().some(v=>v>0)) s.freezeOwner = 0;
}
function nextTurn(s){
  const opp = 3 - s.turn;
  s.turn = opp;
  // 冷却在对手回合开始时-1
  ['sand','freeze','hurl','rewind','simo','genius'].forEach(k=>{
    s.cooldowns[opp][k] = Math.max(0, s.cooldowns[opp][k]-1);
  });
}

/* ---------- Transactions ---------- */
async function txPlace(x,y){
  if(!room||!state) return;
  await runTransaction(ref(db, `rooms/${room}/state`), s=>{
    if(!s || s.winner) return s;

    // backfill
    s.board ??= Array.from({length:BOARD_SIZE},()=>Array(BOARD_SIZE).fill(0));
    s.freeze ??= Array.from({length:BOARD_SIZE},()=>Array(BOARD_SIZE).fill(0));
    s.ruin   ??= Array.from({length:BOARD_SIZE},()=>Array(BOARD_SIZE).fill(0));
    s.voids  ??= Array.from({length:BOARD_SIZE},()=>Array(BOARD_SIZE).fill(0));
    s.recent2 ??= {1:[],2:[]};
    s.lastMoveByPlayer ??= {1:null,2:null};
    s.cooldowns ??= {1:{sand:0,freeze:0,hurl:0,rewind:0,simo:0,genius:0}, 2:{sand:0,freeze:0,hurl:0,rewind:0,simo:0,genius:0}};
    if (typeof s.turn !== 'number') s.turn = 1;
    if (typeof s.freezeOwner !== 'number') s.freezeOwner = 0;

    if(mySeat!==s.turn) return s;
    if(s.board[y][x]!==0) return s;
    if(blocked(x,y)) return s;

    // place
    s.board[y][x]=s.turn;
    s.lastMove={x,y};
    s.lastMoveByPlayer[s.turn]={x,y};
    const arr = s.recent2[s.turn] || [];
    arr.unshift({x,y}); s.recent2[s.turn] = arr.slice(0,2);

    if(checkWin(s.board,x,y,s.turn)){ s.winner=s.turn; return s; }

    decEffects(s);
    nextTurn(s);
    return s;
  });
}

// Sand: wipe 2x2 near one of my last two moves, create ruins
async function txSand(x,y){
  await runTransaction(ref(db, `rooms/${room}/state`), s=>{
    if(!s || s.winner) return s;
    s.cooldowns ??= {1:{sand:0,freeze:0,hurl:0,rewind:0,simo:0,genius:0}, 2:{sand:0,freeze:0,hurl:0,rewind:0,simo:0,genius:0}};
    s.recent2 ??= {1:[],2:[]};
    s.ruin ??= Array.from({length:BOARD_SIZE},()=>Array(BOARD_SIZE).fill(0));

    if(mySeat!==s.turn) return s;
    if(s.cooldowns[mySeat].sand>0) return s;

    const anchors = s.recent2[mySeat] || [];
    const inRange = anchors.some(a=>Math.max(Math.abs(x-a.x), Math.abs(y-a.y))<=1);
    if(!inRange) return s;

    const tlx = clamp(x,0,BOARD_SIZE-2), tly = clamp(y,0,BOARD_SIZE-2);
    for(let dy=0;dy<2;dy++){
      for(let dx=0;dx<2;dx++){
        const cx = tlx+dx, cy = tly+dy;
        if(s.board[cy][cx]===3-mySeat) s.board[cy][cx]=0;
        s.ruin[cy][cx] = Math.max(s.ruin[cy][cx], RUIN_TURNS);
      }
    }
    s.cooldowns[mySeat].sand = CD.sand;
    decEffects(s);
    nextTurn(s);
    return s;
  });
}

// Freeze: 3x3 for 3 turns, exclusive while active
async function txFreeze(cx,cy){
  await runTransaction(ref(db, `rooms/${room}/state`), s=>{
    if(!s || s.winner) return s;
    s.freeze ??= Array.from({length:BOARD_SIZE},()=>Array(BOARD_SIZE).fill(0));
    s.cooldowns ??= {1:{sand:0,freeze:0,hurl:0,rewind:0,simo:0,genius:0}, 2:{sand:0,freeze:0,hurl:0,rewind:0,simo:0,genius:0}};
    s.freezeOwner ??= 0;

    if(mySeat!==s.turn) return s;
    if(s.cooldowns[mySeat].freeze>0) return s;
    if(s.freezeOwner && s.freezeOwner!==mySeat) return s;

    for(let dy=-1;dy<=1;dy++){
      for(let dx=-1;dx<=1;dx++){
        const x=clamp(cx+dx,0,BOARD_SIZE-1), y=clamp(cy+dy,0,BOARD_SIZE-1);
        s.freeze[y][x] = Math.max(s.freeze[y][x], FREEZE_TURNS);
      }
    }
    s.freezeOwner = mySeat;
    s.cooldowns[mySeat].freeze = CD.freeze;
    decEffects(s);
    nextTurn(s);
    return s;
  });
}

// Hurl (改版): choose my stone then a 3x3 target, throw one adjacent opponent stone AND my chosen stone into two random empty cells in target
async function txHurl(from,to){
  await runTransaction(ref(db, `rooms/${room}/state`), s=>{
    if(!s || s.winner) return s;
    s.cooldowns ??= {1:{sand:0,freeze:0,hurl:0,rewind:0,simo:0,genius:0}, 2:{sand:0,freeze:0,hurl:0,rewind:0,simo:0,genius:0}};
    s.freeze ??= Array.from({length:BOARD_SIZE},()=>Array(BOARD_SIZE).fill(0));
    s.ruin ??= Array.from({length:BOARD_SIZE},()=>Array(BOARD_SIZE).fill(0));

    if(mySeat!==s.turn) return s;
    if(s.cooldowns[mySeat].hurl>0) return s;

    const {fx,fy}=from, {cx,cy}=to;
    if(s.board[fy][fx]!==mySeat) return s;
    if(blocked(fx,fy)) return s;

    const opp = 3-mySeat;
    const around = [];
    for(let dy=-1; dy<=1; dy++){
      for(let dx=-1; dx<=1; dx++){
        if(dx===0 && dy===0) continue;
        const x=fx+dx, y=fy+dy;
        if(x<0||y<0||x>=BOARD_SIZE||y>=BOARD_SIZE) continue;
        if(s.board[y][x]===opp) around.push({x,y});
      }
    }
    if(around.length===0) return s;

    const empties = [];
    for(let dy=-1; dy<=1; dy++){
      for(let dx=-1; dx<=1; dx++){
        const x=clamp(cx+dx,0,BOARD_SIZE-1), y=clamp(cy+dy,0,BOARD_SIZE-1);
        if(s.board[y][x]===0 && !blocked(x,y)) empties.push({x,y});
      }
    }
    if(empties.length<2) return s;

    // 随机选一颗对方邻子
    const srcOpp = around[Math.floor(Math.random()*around.length)];
    // 随机两个不同空位
    for(let i=empties.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [empties[i],empties[j]]=[empties[j],empties[i]]; }
    const dstMy = empties[0];
    const dstOpp = empties[1];

    // 执行移动：清空原位，填充目标
    s.board[fy][fx]=0;
    s.board[srcOpp.y][srcOpp.x]=0;
    s.board[dstMy.y][dstMy.x]=mySeat;
    s.board[dstOpp.y][dstOpp.x]=opp;

    s.cooldowns[mySeat].hurl = CD.hurl;
    decEffects(s);
    nextTurn(s);
    return s;
  });
}

// Rewind: remove opponent's most recent move, spawn a 3-turn void at that cell
async function txRewind(){
  await runTransaction(ref(db, `rooms/${room}/state`), s=>{
    if(!s || s.winner) return s;
    s.cooldowns ??= {1:{sand:0,freeze:0,hurl:0,rewind:0,simo:0,genius:0}, 2:{sand:0,freeze:0,hurl:0,rewind:0,simo:0,genius:0}};
    s.lastMoveByPlayer ??= {1:null,2:null};
    s.voids ??= Array.from({length:BOARD_SIZE},()=>Array(BOARD_SIZE).fill(0));

    if(mySeat!==s.turn) return s;
    if(s.cooldowns[mySeat].rewind>0) return s;

    const opp = 3-mySeat;
    const lm = s.lastMoveByPlayer[opp];
    if(!lm) return s;
    if(s.board[lm.y][lm.x]!==opp) return s;

    s.board[lm.y][lm.x]=0;
    s.lastMove = null;
    s.lastMoveByPlayer[opp]=null;
    s.voids[lm.y][lm.x] = Math.max(s.voids[lm.y][lm.x], VOID_TURNS);

    s.cooldowns[mySeat].rewind = CD.rewind;
    decEffects(s);
    nextTurn(s);
    return s;
  });
  sysMsg('回溯时光：对手上一手被移除，原位生成黑洞 3 回合');
}

// Simo: 四面楚歌 - 选择一枚被完全包围的己方子，随机移除其周围两颗对方子
async function txSimo(x,y){
  await runTransaction(ref(db, `rooms/${room}/state`), s=>{
    if(!s || s.winner) return s;
    s.cooldowns ??= {1:{sand:0,freeze:0,hurl:0,rewind:0,simo:0,genius:0}, 2:{sand:0,freeze:0,hurl:0,rewind:0,simo:0,genius:0}};
    if(mySeat!==s.turn) return s;
    if(s.cooldowns[mySeat].simo>0) return s;
    if(s.board[y][x]!==mySeat) return s;

    // 确认被包围
    const opp = 3-mySeat;
    const around = [];
    for(let dy=-1; dy<=1; dy++){
      for(let dx=-1; dx<=1; dx++){
        if(dx===0 && dy===0) continue;
        const nx=x+dx, ny=y+dy;
        if(nx<0||ny<0||nx>=BOARD_SIZE||ny>=BOARD_SIZE) return s;
        if(s.board[ny][nx]!==opp) return s;
        around.push({x:nx,y:ny});
      }
    }
    if(around.length<2) return s;

    // 打乱并移除两颗
    for(let i=around.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [around[i],around[j]]=[around[j],around[i]]; }
    const a=around[0], b=around[1];
    s.board[a.y][a.x]=0; s.board[b.y][b.x]=0;

    s.cooldowns[mySeat].simo = CD.simo;
    decEffects(s);
    nextTurn(s);
    return s;
  });
}

// Genius: 神来一笔 - 直接在指定空位落子（预览由本地产生）
async function txGenius(x,y){
  await runTransaction(ref(db, `rooms/${room}/state`), s=>{
    if(!s || s.winner) return s;
    // backfill
    s.board ??= Array.from({length:BOARD_SIZE},()=>Array(BOARD_SIZE).fill(0));
    s.freeze ??= Array.from({length:BOARD_SIZE},()=>Array(BOARD_SIZE).fill(0));
    s.ruin   ??= Array.from({length:BOARD_SIZE},()=>Array(BOARD_SIZE).fill(0));
    s.voids  ??= Array.from({length:BOARD_SIZE},()=>Array(BOARD_SIZE).fill(0));
    s.recent2 ??= {1:[],2:[]};
    s.lastMoveByPlayer ??= {1:null,2:null};
    s.cooldowns ??= {1:{sand:0,freeze:0,hurl:0,rewind:0,simo:0,genius:0}, 2:{sand:0,freeze:0,hurl:0,rewind:0,simo:0,genius:0}};
    if (typeof s.turn !== 'number') s.turn = 1;

    if(mySeat!==s.turn) return s;
    if(s.cooldowns[mySeat].genius>0) return s;
    if(s.board[y][x]!==0) return s;
    if(blocked(x,y)) return s;

    s.board[y][x]=s.turn;
    s.lastMove={x,y};
    s.lastMoveByPlayer[s.turn]={x,y};
    const arr = s.recent2[s.turn] || [];
    arr.unshift({x,y}); s.recent2[s.turn] = arr.slice(0,2);

    s.cooldowns[mySeat].genius = CD.genius;

    if(checkWin(s.board,x,y,s.turn)){ s.winner=s.turn; return s; }
    decEffects(s);
    nextTurn(s);
    return s;
  });
}

/* ---------- Reset room ---------- */
async function resetRoom(){
  if(!room){ alert('请先进入房间'); return; }
  await runTransaction(ref(db, `rooms/${room}/state`), ()=> emptyState());
  prevWinner = 0;
  winModal.style.display='none';
  setHint('已开始新局');
  sysMsg('系统：新局已开始');
}

/* ---------- Input handling ---------- */
canvas.addEventListener('mousemove', ev=>{
  hoverCell = screenToCell(ev);
  drawBoard();
});

canvas.addEventListener('click', ev=>{
  if(!state || state.winner) return;
  const {x,y} = screenToCell(ev);
  if(mySeat===0){ setHint('旁观模式不能操作'); return; }

  if(mode==='place') return txPlace(x,y);
  if(mode==='sand') return txSand(x,y);
  if(mode==='freeze') return txFreeze(x,y);
  if(mode==='hurlSelect'){
    if(state.board[y][x]!==mySeat){ setHint('请选择己方一子'); return; }
    if(blocked(x,y)){ setHint('此子被限制，无法使用'); return; }
    leapFrom = {fx:x, fy:y}; mode='hurlTarget'; setHint('选择任意位置作为3×3目标区域中心');
    return;
  }
  if(mode==='hurlTarget'){
    const cx = x, cy = y;
    leapFrom = leapFrom || {fx:x,fy:y};
    mode='place';
    const from = {fx:leapFrom.fx, fy:leapFrom.fy}, to = {cx,cy};
    leapFrom=null; return txHurl(from,to);
  }
  if(mode==='simo'){
    // 仅允许点击高亮候选
    const cands = listSimoCandidates(state.turn);
    if(!cands.some(p=>p.x===x && p.y===y)){ setHint('请选择高亮的己方被包围棋子'); return; }
    mode='place'; return txSimo(x,y);
  }
  if(mode==='geniusPreview'){
    // 预览期间点击棋盘不落子，通过按钮二次确认；提示可切回“落子模式”放弃
    setHint('已抽取空位，再次点击“神来一笔”确认；或点“落子模式”放弃');
    return;
  }
});

btnPlace.onclick = ()=>{
  mode='place'; geniusPick=null; leapFrom=null;
  setHint('落子模式');
  drawBoard(); updateUI();
};
btnReset.onclick = resetRoom;

// 允许在非己方回合进行预览：始终切换模式，若不可用则仅提示“预览中”
btnSand.onclick = ()=>{
  mode='sand';
  setHint(canUse('sand') ? '飞沙走石：点靠近你最近两手之一的2×2区域' : '飞沙走石（预览）：非己方回合或冷却中，无法释放');
  drawBoard();
};
btnFreeze.onclick = ()=>{
  mode='freeze';
  setHint(canUse('freeze') ? '静如止水：点一个中心，冻结3×3三回合' : '静如止水（预览）：非己方回合或冷却中，无法释放');
  drawBoard();
};
btnHurl.onclick = ()=>{
  mode='hurlSelect';
  setHint(canUse('hurl') ? '力拔山兮：先点己方一子，再点3×3目标区域中心（你与一颗邻近对方子将被甩到目标区的两个空位）' : '力拔山兮（预览）：非己方回合或冷却中，无法释放');
  drawBoard();
};
btnRewind.onclick = ()=>{
  mode='rewindPreview';
  if(canUse('rewind')){
    setHint('回溯时光：再次点击“回溯时光”以确认释放');
    // 二次点击确认释放
    const once = ()=>{
      if(mode==='rewindPreview' && canUse('rewind')){
        txRewind();
        setHint('已回溯：该格出现 3 回合黑洞');
      }
      btnRewind.removeEventListener('click', once);
      mode='place';
      drawBoard();
    };
    btnRewind.addEventListener('click', once);
  }else{
    setHint('回溯时光（预览）：高亮对手上一手；非己方回合或冷却中，无法释放');
  }
  drawBoard();
};

// 新增按钮行为：四面楚歌
btnSimo.onclick = ()=>{
  mode='simo';
  if(canUse('simo')){
    const cands = listSimoCandidates(state.turn);
    if(cands.length===0){
      setHint('没有四面楚歌的棋子');
      mode='place';
    }else{
      setHint('四面楚歌：点击高亮的己方被包围棋子');
    }
  }else{
    setHint('四面楚歌（预览）：当前不可释放');
  }
  drawBoard();
};

// 新增按钮行为：神来一笔（两段式确认 + 动画）
btnGenius.onclick = ()=>{
  if(mode!=='geniusPreview'){
    mode='geniusPreview';
    if(canUse('genius')){
      geniusPick = pickRandomEmpty();
      if(!geniusPick){ setHint('没有空位可用'); mode='place'; drawBoard(); return; }
      setHint('神来一笔：再次点击“神来一笔”确认；或点“落子模式”放弃');
      drawBoard();
      // 二次点击确认
      const once = ()=>{
        if(mode==='geniusPreview' && geniusPick && canUse('genius')){
          animateDrop(geniusPick.x, geniusPick.y, state.turn);
          txGenius(geniusPick.x, geniusPick.y);
        }
        btnGenius.removeEventListener('click', once);
        geniusPick=null; mode='place';
        drawBoard();
      };
      btnGenius.addEventListener('click', once);
    }else{
      setHint('神来一笔（预览）：当前不可释放');
      drawBoard();
    }
  }else{
    // 已在上方 once 绑定处理
  }
};

function canUse(kind){
  if (!state) return false;
  if (mySeat !== 1 && mySeat !== 2) return false;
  if (state.turn !== mySeat) return false;
  const cd = state.cooldowns?.[mySeat]?.[kind];
  if (typeof cd !== 'number' || cd>0) return false;
  if(kind==='sand'){
    const arr = state.recent2?.[mySeat] || [];
    if(arr.length===0) return false;
  }
  if(kind==='freeze'){
    if(state.freezeOwner && state.freezeOwner!==mySeat) return false;
  }
  if(kind==='rewind'){
    const lm = state.lastMoveByPlayer?.[3-mySeat];
    if(!lm) return false;
  }
  if(kind==='simo'){
    const cands = listSimoCandidates(mySeat);
    if(cands.length===0) return false;
  }
  if(kind==='genius'){
    // 仅检查 CD 与回合，具体空位在点击后再选
  }
  return true;
}

// 简单缩放落子动画（本地视觉，不写回状态）
function animateDrop(x,y,player){
  const cx = MARGIN + x*CELL;
  const cy = MARGIN + y*CELL;
  const R = CELL*0.42;
  const start = performance.now();
  function frame(now){
    const t = Math.min(1, (now-start)/220);
    drawBoard();
    const r = R*(1.6 - 0.6*t);
    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = (player===1)?'#111':'#fff';
    ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();
    ctx.restore();
    if(t<1) requestAnimationFrame(frame); else drawBoard();
  }
  requestAnimationFrame(frame);
}

/* ---------- Chat send ---------- */
function sendChat(){
  if(!room) return;
  const text = chatInput.value.trim();
  if(!text) return;
  push(ref(db, `rooms/${room}/chat`), {
    uid, name: nickname || '玩家', seat: mySeat, text, ts: serverTimestamp()
  });
  chatInput.value = "";
  chatInput.focus();
}
chatSend.onclick = sendChat;
chatInput.addEventListener('keydown', e=>{
  if(e.key==='Enter') sendChat();
});

/* ---------- Boot ---------- */
drawBoard();
setHint('请输入房间号并加入');
</script>
</body>
</html>
